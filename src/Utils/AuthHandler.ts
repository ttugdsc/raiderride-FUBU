/**
 * This module contains implementations of different OAuth2 requests for abstraction purposes
 * @module
 */

import axios, {AxiosInstance} from 'axios';
import Config from 'react-native-config';
import qs from 'qs';
import {TokenResponse} from '../App';
import InAppBrowser, {
  InAppBrowserOptions,
} from 'react-native-inappbrowser-reborn';
import {Linking} from 'react-native';
import {URL} from 'react-native-url-polyfill';

const inAppBrowserConfig: InAppBrowserOptions = {
  //IOS CONFIG OPTIONS
  dismissButtonStyle: 'cancel',
  readerMode: false,
  animated: true,
  modalPresentationStyle: 'fullScreen',
  modalTransitionStyle: 'coverVertical',
  modalEnabled: true,
  enableBarCollapsing: false,
  //ANDRIOD CONFIG OPTIONS
  showTitle: false,
  enableUrlBarHiding: true,
  enableDefaultShare: false,
  forceCloseOnRedirection: true,
  hasBackButton: true,
};

class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthHandler Error';
  }
}

class OAuthError extends Error {
  constructor(type: string, description: string) {
    super(`${type}: ${description}`);
    this.name = 'OAuth Error';
  }
}

/**
 * The reponse returned by the /me endpoint at the Microsoft 365 Graph API.
 * @see [The Graph Api Explorer](https://developer.microsoft.com/en-us/graph/graph-explorer)
 */
export type GraphResponse = {
  /**
   * The display name of the user, for TTU the format is:
   * lastName, firstName
   */
  displayName: string;
  /**
   * The first name of the user.
   */
  givenName: string;
  jobTitle: string | null;
  mail: string;
  /**
   * The last name of the user.
   */
  surname: string;
  /**
   * The unique id generated by Microsoft 365, not the student id.
   */
  id: string;
};

/**
 * Used to send various requests to Microsoft OAuth Endpoints
 * @author Jaxcksn
 * @kind class
 */
class AuthHandler {
  /**
   * The axios instance for making requests
   */
  private axios: AxiosInstance;

  public constructor() {
    this.axios = axios.create({
      baseURL: `https://login.microsoftonline.com/${Config.TENANT}/oauth2/v2.0/`,
    });
  }

  /**
   * Generates a random string to use as a state variable.
   */
  private generateState(): string {
    return (
      Math.random().toString(36).substring(2, 10) +
      Math.random().toString(36).substring(2, 10)
    );
  }

  /**
   * Starts a listener for the apps URI, and if it's the authentication end point,
   * it will return the auth code from the response.
   *
   * @returns {Promise<string>} A string containing the authentication code.
   * @param {string} state This should match the state sent in the auth request, it's used to prevent CSFR attacks.
   * @async
   */
  private async startLinkListener(state: string): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      Linking.addEventListener('url', data => {
        // First, we clear the existing listener.
        Linking.removeAllListeners('url');
        let url = new URL(data.url);

        //Check the hostname
        if (url.hostname === 'auth') {
          if (url.searchParams.get('error') !== null) {
            // We should reject because of this response.
            reject(
              new OAuthError(
                url.searchParams.get('error')!,
                url.searchParams.get('error_description')!,
              ),
            );
          } else if (url.searchParams.get('code') === null) {
            // We should also reject because of this.
            reject(
              new AuthError(
                'Auth code query params is missing from callback URI.',
              ),
            );
          } else if (url.searchParams.get('state') !== state) {
            reject(new AuthError('Invalid state was supplied.'));
          } else {
            // Resolve with the authentication code.
            resolve(url.searchParams.get('code')!);
          }
        } else {
          //Reject the promise, invalid hostname;
          reject(new AuthError('Invalid hostname found for deep link URI.'));
        }
      });

      setTimeout(() => {
        Linking.removeAllListeners('url');
        reject(
          new AuthError('Auth code listener timed out before URL event fired.'),
        );
      }, 600000);
    });
  }

  /**
   * Opens a browser for the user, to the authentication code link.
   * @throws {AuthError} Message contains details on error.
   * @async
   */
  async getAuthCode(): Promise<string> {
    const state = this.generateState();
    const oauthURL =
      'https://login.microsoftonline.com/178a51bf-8b20-49ff-b655-56245d5c173c/oauth2/v2.0/authorize?client_id=fc0978bf-d586-4d85-8933-5cea1cdd8ecf&response_type=code&redirect_uri=raiderride://auth&scope=https://graph.microsoft.com/User.Read&state=' +
      state;

    if (await InAppBrowser.isAvailable()) {
      let result = await InAppBrowser.openAuth(
        oauthURL,
        'raiderride://auth',
        inAppBrowserConfig,
      );

      if (result.type === 'success' && result.url) {
        let url = new URL(result.url);

        //Check the hostname
        if (url.hostname === 'auth') {
          if (url.searchParams.get('error') !== null) {
            // We should throw because of this response.
            throw new OAuthError(
              url.searchParams.get('error')!,
              url.searchParams.get('error_description')!,
            );
          } else if (url.searchParams.get('code') === null) {
            // We should also throw because of this.
            throw new AuthError(
              'Auth code query params is missing from callback URI.',
            );
          } else if (url.searchParams.get('state') !== state) {
            // To prevent CSFR attacks
            throw new AuthError('Invalid state was supplied.');
          } else {
            // Return with the authentication code.
            return url.searchParams.get('code')!;
          }
        } else {
          //Throw an error, invalid hostname;
          throw new AuthError('Invalid hostname found for deep link URI.');
        }
      } else {
        throw new AuthError('Error during OAuth Flow');
      }
    } else {
      Linking.openURL(oauthURL);
      try {
        let code = await this.startLinkListener(state);
        return code;
      } catch (e: any) {
        throw e;
      }
    }
  }

  /**
   * Sends a request for an accessToken using an access code.
   * @param {string} code The access code returned from initial oAuth2 step
   * @returns {Promise<TokenResponse>} A promise with a token response.
   * @async
   */
  async getAccessToken(code: string): Promise<TokenResponse> {
    let response = this.axios.post(
      '/token',
      qs.stringify({
        client_id: 'fc0978bf-d586-4d85-8933-5cea1cdd8ecf',
        code: code,
        redirect_uri: 'raiderride://auth',
        scope: 'offline_access https://graph.microsoft.com/User.Read',
        grant_type: 'authorization_code',
      }),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      },
    );

    return (await response).data;
  }

  /**
   * Gets a new access token and refresh token from the stored refresh token.
   *
   * @param refreshToken The refresh token to send to the endpoint.
   * @returns {Promise<TokenResponse>} The response from calling the api.
   */
  async getFromRefreshToken(refreshToken: string): Promise<TokenResponse> {
    let response = await this.axios.post(
      '/token',
      qs.stringify({
        client_id: 'fc0978bf-d586-4d85-8933-5cea1cdd8ecf',
        refresh_token: refreshToken,
        grant_type: 'refresh_token',
      }),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      },
    );

    return response.data;
  }

  /**
   * Sends a request to the /me endpoint to get the data of the authorized user.
   *
   * @param {string} accessToken The access token to use for the request.
   * @returns {Promise<GraphResponse>} A promise, with the graph response data.
   */
  async getUserData(accessToken: string): Promise<GraphResponse> {
    let response = await axios.get('https://graph.microsoft.com/v1.0/me', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });

    return response.data;
  }
}

/**
 * An instance of the {@linkcode AuthHandler} class
 */
export const authHandler = new AuthHandler();
